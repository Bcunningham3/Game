"""
Game (Name TBD)
By: Brandon Cunningham
Version 0.2.1

Start Date: 10/14/2018
Finish Date: 10/15/2018

This version changed up graphics by showing an always up to date score board at the bottom of the screen, and displaying
whose turn it is at the top, along with whatever other information needs to be displayed. There were also minor bug
fixes, so now the program exits if you click cancel or x out of one of the input boxes instead of the program crashing.
Also, this shouldn't have effected any games, but the bug where if all scores were negative and the game wasn't 4 player
then the wrong winner would be announced has been fixed.
Fixed a major bug where row and column were switched when you entered where you wanted to go.
"""


import turtle as t
import random as r
import time
t.tracer(0,0)
t.ht()


"""
All numbers must stick within a 20 by 40 rectangle.
the starting coordinates for 1 digit number is (40,30) from left hand corner.
The starting and ending position of each of these numbers will be the bottom left hand corner of their rectangles.
They will all start facing the right side wall and end the same direction.
All functions draw the number/symbol that is their function name.
"""
def num1():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.backward(10)
    t.left(90)
    t.forward(40)
    t.left(135)
    t.forward(14)
    t.up()
    t.goto(x,y)
    t.right(225)


def num2():
    x=t.xcor()
    y=t.ycor()
    t.down()
    t.forward(20)
    t.backward(20)
    t.left(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.up()
    t.left(180)
    t.goto(x,y)


def num3():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.backward(20)
    t.right(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.up()
    t.goto(x, y)
    t.left(180)


def num4():
    x = t.xcor()
    y = t.ycor()
    t.up()
    t.forward(17)
    t.left(90)
    t.down()
    t.forward(40)
    t.left(150)
    t.forward(34)
    t.left(120)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num5():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num6():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.left(90)
    t.forward(40)
    t.right(90)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num7():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.goto(t.xcor()+20, t.ycor()+40)
    t.backward(20)
    t.up()
    t.goto(x, y)


def num8():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.left(90)
    t.forward(20)
    t.right(90)
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.up()
    t.goto(x, y)


def num9():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(40)
    for z in range(3):
        t.left(90)
        t.forward(20)
    t.up()
    t.goto(x, y)


def num0():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(2):
        t.forward(20)
        t.left(90)
        t.forward(40)
        t.left(90)
    t.up()
    t.goto(x, y)


def minus():
    x = t.xcor()
    y = t.ycor()
    t.goto(x, y+20)
    t.down()
    t.forward(20)
    t.up()
    t.goto(x, y)


def plus():
    x = t.xcor()
    y = t.ycor()
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.down()
    t.forward(20)
    t.backward(10)
    t.right(90)
    t.backward(10)
    t.forward(20)
    t.up()
    t.goto(x, y)


def star():
    t.pencolor("black")
    x = t.xcor()
    y = t.ycor()
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.down()
    t.forward(20)
    t.backward(10)
    t.right(90)
    t.backward(10)
    t.forward(20)
    t.backward(10)
    t.left(45)
    t.forward(10)
    t.backward(20)
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.backward(20)
    t.forward(10)
    t.left(135)
    t.left(90)
    t.up()
    t.goto(x, y)


def draw_X():
    x = t.xcor()
    y = t.ycor()
    t.pencolor("black")
    t.forward(15)
    t.down()
    t.fillcolor("black")
    t.begin_fill()
    t.forward(5)
    t.goto(x+5, y+40)
    t.backward(5)
    t.goto(x+15, y)
    t.end_fill()
    t.up()
    t.backward(15)
    t.down()
    t.begin_fill()
    t.forward(5)
    t.goto(t.xcor()+15, t.ycor()+40)
    t.backward(5)
    t.goto(x,y)
    t.end_fill()
    t.up()


def calculate(board, numP, scores, neg, player, p_spots, negate):
    """
    This is the function that will calculate your score based on the position you've chosen.
    :param board:
    :param numP:
    :param scores:
    :param neg:
    :param player:
    :param p_spots:
    :param negate:
    :return:
    """
    x=True
    n=0
    power_up=False
    TIMS=False
    while x:
        (row, col) = inputs(len(board), len(board[0]), player)
        spot = board[row][col]
        if spot == '$' or spot == '$-':
            if negate[player-1] > 0:
                TIMS=True
            (num)=adder(board, row, col)
            p_spots[player-1].append((row,col))
            if num == 0:
                num = 1
            if neg > 0:
                num *= -1
            if TIMS:
                num*=-1
                negate[player-1]-=1
            if spot == '$-':
                error_text("Trap Hit!", board)
                num=int(num*(-1.5))
            x = False
        elif spot == '*' or spot == '*-':
            A = board[row - 1][col]
            B = board[row + 1][col]
            C = board[row][col + 1]
            D = board[row][col - 1]
            if (A == '$' or A == '*') and (B == '$' or B == '*') and (C == '$' or C == '*') and (D == '$' or D == '*'):
                error_text("There must be a pre-chosen tile next to a power up in order to choose it.\nPlease try again.", board)
            else:
                num = adder(board, row, col)
                p_spots[player - 1].append((row, col))
                if negate[player - 1] > 0:
                    TIMS = True
                (num, scores, n, power_up, negate) = rand_power_up(num, numP, scores, board, player, negate)
                if neg > 0:
                    num *= -1
                if TIMS:
                    num *= -1
                    negate[player - 1] -= 1
                if spot == '*-':
                    error_text("Trap Hit!", board)
                    num = int(num * (-1.5))
                if power_up=="Twice Opp":
                    scores = twiceOpponent(num, numP, scores, player)
                    num = 0
                t.up()
                t.goto(row*100, col*100)
                fill_spot("white")
                x = False
        elif spot == 'X':
            error_text("You cannot choose a spot that has already been 'X'ed out.", board)
        else:
            error_text("You can't choose a position that has a value, please try again.", board)
    if n > 0 and neg > 0:
        neg += n - 1
    else:
        neg += n
    board[row][col] = num
    return board, row, col, scores, neg, p_spots, power_up


def adder(board, row, col):
    x = board[row - 1][col]
    if x == '*' or x == '$' or x == 'X':
        num=0
    else:
        num=x
    x = board[row + 1][col]
    if x != '*' and x != '$' and x != 'X':
        num+=x
    x = board[row][col + 1]
    if x != '*' and x != '$' and x != 'X':
        num+=x
    x = board[row][col - 1]
    if x != '*' and x != '$' and x != 'X':
        num+=x
    return num


def rand_power_up(num, numP, scores, board, player, negate):
    x = r.randint(1, 11)
    power_up = ""
    neg = 0
    if x==1:
        error_text("Scored Turned Negative", board)
        num*=-1
    elif x==2:
        error_text("10 subtracted from Score", board)
        num-=10
    elif x == 3:
        power_up="Twice Opp"
    elif x == 4:
        error_text("10 added to Score", board)
        num+=10
    elif x == 5:
        error_text("Score Multiplied by 2", board)
        num*=2
    elif x == 6:
        power_up = 'Choose X'
    elif x == 7:
        neg=negOpponents(numP, board)
    elif x == 8:
        power_up = 'Random X'
    elif x == 9:
        power_up = "Trap"
    elif x == 10:
        error_text("Your next turn will be negated", board)
        negate[player-1]+=1
    elif x == 11:
        power_up = 'Swap'
        """
        Ideas: 
        All implemented
        """
    return num, scores, neg, power_up, negate


def trap(board, player):
    x = True
    error_text("Pick a spot to place a trap", board)
    while x:
        (row, col) = inputs(len(board), len(board[0]), player)
        if board[row][col] == '$':
            board[row][col] = '$-'
            x = False
        elif board[row][col] == '*':
            board[row][col] = '*-'
            x = False
        elif board[row][col] == 'X':
            error_text("You cannot choose a spot that has already been 'X'ed out.", board)
        elif board[row][col] == '*-' or board[row][col] == '$-':
            x = False
        else:
            error_text("You can't choose a position that has already been chosen, please try again.", board)
    error_text("Trap Placed", board)


def Xout(board, scores, p_spots, player):
    error_text("Chose a spot that will be 'X'ed out", board)
    boo=True
    while boo:
        row=get_row(len(board)-2, player)
        col=get_col(len(board[0])-2, player)
        if board[row][col] != 'X':
            boo=False
            Xing(board, row, col, p_spots, scores)
        else:
            error_text("You cannot pick a spot that has already been 'X'ed out", board)


def Xing(board, row, col, p_spots, scores):
    if (row, col) in p_spots[0]:
        scores[0]-=board[row][col]
    elif (row, col) in p_spots[1]:
        scores[1]-=board[row][col]
    elif (row, col) in p_spots[2]:
        scores[2]-=board[row][col]
    elif (row, col) in p_spots[3]:
        scores[3]-=board[row][col]
    board[row][col]='X'
    display_X(row, col)


def RandX(board, scores, p_spots, player):
    x=int((len(board[0])-2)*(len(board)-2)*.2)
    if x==1:
        x=2
    x=power_up_spots(board, x)
    num = get_num(player, x)
    while num > 0:
        row = r.randint(1, len(board) - 2)
        col = r.randint(1, len(board[0]) - 2)
        if board[row][col] != 'X':
            Xing(board, row, col, p_spots, scores)
            num -= 1


def get_num(player, x):
    try:
        return int(t.numinput("Player %d" % player, "Enter number of 'X's to be randomly placed on board, between 1 and %d: " % x, 1, 1, x))
    except TypeError:
        exit()


def swap(board, p_spots, scores, player):
    error_text("Choose two spots on the board to swap Values. Enter first spot", board)
    row1 = get_row(len(board) - 2, player)
    col1 = get_col(len(board[0]) - 2, player)
    error_text("Choose second spot", board)
    row2 = get_row(len(board) - 2, player)
    col2 = get_col(len(board[0]) - 2, player)
    (val1, p1) = get_val(p_spots, board, scores, row1, col1)
    (val2, p2) = get_val(p_spots, board, scores, row2, col2)
    t.up()
    board[row1][col1] = val2
    board[row2][col2] = val1
    try:
        scores[p1] += val2
    except TypeError:
        pass
    try:
        scores[p2] += val1
    except TypeError:
        pass
    if p1 > -1 and p2 == -1:
        p_spots[p1].remove((row1, col1))
    if p2 > -1 and p1 == -1:
        p_spots[p2].remove((row2, col2))
    draw_swapped(val2, p1, row1, col1)
    draw_swapped(val1, p2, row2, col2)
    return board, scores, p_spots


def draw_swapped(val, p, row, col):
    t.goto(row * 100, col * 100)
    fill_spot("white")
    if val != '$':
        if p==-1:
            t.pencolor("black")
        elif p==0:
            t.pencolor("red")
        elif p==1:
            t.pencolor("blue")
        elif p==2:
            t.pencolor("green")
        elif p==3:
            t.pencolor("purple")
        draw_number(row, col, val)


def get_val(p_spots, board, scores, row1, col1):
    p=-1
    if (row1, col1) in p_spots[0]:
        p=0
        try:
            scores[0] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[1]:
        p=1
        try:
            scores[1] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[2]:
        p=2
        try:
            scores[2] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[3]:
        p=3
        try:
            scores[3] -= board[row1][col1]
        except TypeError:
            pass
    return board[row1][col1], p


def power_up_spots(board, x):
    check=0
    for y in range(1, len(board)-1):
        for z in range(1, len(board[0])-1):
            if board[y][z]!='X':
                check+=1
                if x==check:
                    return check
    return check


def display_X(row, col):
    t.up()
    t.goto(row * 100, col * 100)
    fill_spot("white")
    one_digit('X')


def negOpponents(numP, board):
    error_text("All opponents next turns will be negative", board)
    return numP


def twiceOpponent(num, numP, scores, p):
        player=get_player(numP, p, (num*2))
        scores[player-1]-=(num*2)
        return scores


def inputs(w, h, player):
    """
    Temporary input method, will later change to graphics and mouse clicking.
    Or at least that is the plan, pygame was not working and I unfortunately
    may not be able to get it implemented in time.
    """
    row=get_row(w-2, player)
    col=get_col(h-2, player)
    return row, col


def get_player(numP, player, num):
    try:
        return int(t.numinput("Player %d" % player, "Enter player number who will have " + str(num) + " subtracted from their score, between 1 and %d: " % numP, 1, 1, numP))
    except TypeError:
        exit()


def get_row(h, player):
    try:
        return int(t.numinput("Player %d" % player, "Enter row number, between 1 and %d: " % h, 1, 1, h))
    except TypeError:
        exit()


def get_col(w, player):
    try:
        return int(t.numinput("Player %d" % player, "Enter column number, between 1 and %d: " % w, 1, 1, w))
    except TypeError:
        exit()


def get_width():
    try:
        return int(t.numinput("Width", "Enter playable board width, between 3 and 10: ", 5, 3, 10))
    except TypeError:
        exit()

def get_height():
    try:
        return int(t.numinput("Height", "Enter playable board height, between 3 and 10: ", 5, 3, 10))
    except TypeError:
        exit()


def initialize_board():
    width = get_width()
    height = get_height()
    w, h = width+2, height+2
    board = [['$' for x in range(h)] for y in range(w)]
    for x in range(w):
        board[x][0] = 1
        board[x][h-1] = 1
    for x in range(h):
        board[0][x] = 1
        board[w-1][x] = 1
    t.setworldcoordinates(-25, -130, (w*100)+30, (h*100)+80)
    return board


def draw_board(w, h):
    t.up()
    t.pencolor("black")
    t.home()
    t.right(90)
    for x in range(0, w+1):
        t.goto(x*100, 0)
        t.down()
        t.backward(h*100)
        t.up()
    t.left(90)
    for x in range(0, h+1):
        t.goto(0, x * 100)
        t.down()
        t.forward(w * 100)
        t.up()
    t.home()
    fill_spot("black")
    t.goto(0, (h-1)*100)
    fill_spot("black")
    t.goto((w-1)*100, 0)
    fill_spot("black")
    t.goto((w-1)*100, (h-1)*100)
    fill_spot("black")
    t.home()


def draw_1s(w, h):
    for x in range(1, w-1):
        t.goto((x*100)+40, 30)
        num1()
        t.goto((x * 100) + 40, (h*100)-70)
        num1()
    for x in range(1, h-1):
        t.goto(40, (x*100)+30)
        num1()
        t.goto((w*100)-60, (x * 100) + 30)
        num1()
    t.goto(-100,-100)
    t.update()


def fill_spot(string):
    """
    Draws the black corners in the game, and clears spots that are being drawn over
    """
    t.down()
    t.pencolor('black')
    t.fillcolor(string)
    t.begin_fill()
    for x in range(4):
        t.forward(100)
        t.left(90)
    t.end_fill()
    t.up()


def draw_number(row, col, num):
    """
    Will print the score onto the drawn board
    """
    t.up()
    t.goto(row*100, col*100)
    try:
        if num > 999:
            num = "999+"
        if num < -999:
            num = "-999"
    except TypeError:
        pass
    num = str(num)
    if len(num) == 1:
        one_digit(num)
    elif len(num) == 2:
        two_digit(num)
    elif len(num) == 3:
        three_digit(num)
    else:
        more_digit(num)
    t.goto(-100,-100)
    t.update()


def one_digit(num):
    t.forward(40)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num)


def two_digit(num):
    t.forward(28)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])


def three_digit(num):
    t.forward(16)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])
    t.forward(24)
    draw_char(num[2])

def more_digit(num):
    t.forward(4)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])
    t.forward(24)
    draw_char(num[2])
    t.forward(24)
    draw_char(num[3])


def draw_char(char):
    if char == '*':
        star()
    elif char == '1':
        num1()
    elif char == '2':
        num2()
    elif char == '3':
        num3()
    elif char == '4':
        num4()
    elif char == '5':
        num5()
    elif char == '6':
        num6()
    elif char == '7':
        num7()
    elif char == '8':
        num8()
    elif char == '9':
        num9()
    elif char == '0':
        num0()
    elif char== '-':
        minus()
    elif char == '+':
        plus()
    elif char == 'X':
        draw_X()


def player_num(scores):
    try:
        numP = int(t.numinput("Players", "Enter number of players, between 2 and 4: ", 2, 2, 4))
    except TypeError:
        exit()
    if numP>2:
        scores[2] = 0
    if numP>3:
        scores[3] = 0
    return numP, scores


def get_input():
    """
    Future ability to be able to click on the screen instead of having to type in
    the spots you choose to play in.
    This may turn out to be a very future thing because I cannot get pygame working.
    """
    pass
    #return row, col


def checker(board):
    """
    checks the board to see if there are any playable spots left
    :param board: the current state of the game board
    :return: wether or not the board is full and the game is over
    """
    for x in range(len(board)-1):
        for y in range(len(board[0])-1):
            if board[x+1][y+1]=='$' or board[x+1][y+1]=='*':
                return True
    return False


def end(scores, numP, board):
    clear_player_turn(board)
    if numP==2 and scores[0]==scores[1]:
        error_text("It's a Tie", board)
    if scores[0] > scores[1]:
        p1='Player 1'
        val1=scores[0]
    else:
        p1='Player 2'
        val1=scores[1]
    if scores[2] > scores[3]:
        p2='Player 3'
        val2=scores[2]
    else:
        p2='Player 4'
        val2=scores[3]
    if val1>val2:
        error_text(p1 + " Wins!!!", board)
    elif val2>val1:
        error_text(p2 + " Wins!!!", board)
    else:
        error_text("It's a Tie", board)


def power_ups_on(board):
    x=t.textinput("Game Mode", "Would you like to turn on power ups? (Enter Yes to turn them on or press enter to not)")
    return check_yes(x, board)


def mayhem_on(board):
    x = t. textinput("Game Mode", "Would you like to turn on mayhem mode? (Enter Yes to turn them on or press enter to not)")
    return check_yes(x, board)


def check_yes(x, board):
    try:
        x = x.upper()
    except:
        exit()
    if x != 'YES':
        return False
    error_text("Turned On", board)
    return True


def check_yes_no_print(x):
    try:
        x = x.upper()
    except:
        exit()
    if x != 'YES':
        return False
    return True


def power_init(board, boo):
    if not boo:
        spots = (len(board) - 2) * (len(board[0]) - 2)
        spots //= 7
        while spots > 0:
            row = r.randint(1, len(board) - 2)
            col = r.randint(1, len(board[0]) - 2)
            if board[row][col] != '*':
                board[row][col] = '*'
                display_power_ups(row, col)
                spots -= 1
    else:
        for row in range(1, len(board)-1):
            for col in range(1, len(board[0])-1):
                board[row][col] = '*'
                display_power_ups(row, col)
    return board


def display_power_ups(row, col):
    t.up()
    t.goto(row * 100, col * 100)
    one_digit('*')


def clear_players(board):
    t.goto(0,-1)
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(len(board)*100)
        t.right(90)
        t.forward(150)
        t.right(90)
    t.end_fill()


def draw_players(numP, board, scores):
    t.up()
    clear_players(board)
    t.goto(0, -50)
    t.down()
    t.pencolor("red")
    t.write("Player 1: %d"% scores[0], font=("OCR-A", 16, "normal"))
    t.up()
    t.goto((len(board)*100)/2, -50)
    t.down()
    t.pencolor("blue")
    t.write("Player 2: %d"% scores[1], font=("OCR-A", 16, "normal"))
    t.up()
    if numP>2:
        t.pencolor("green")
        t.goto(0, -100)
        t.down()
        t.write("Player 3: %d" % scores[2], font=("OCR-A", 16, "normal"))
        t.up()
    if numP>3:
        t.pencolor("purple")
        t.goto((len(board) * 100) / 2, -100)
        t.down()
        t.write("Player 4: %d" % scores[3], font=("OCR-A", 16, "normal"))
        t.up()
    t.goto(-100,-100)
    t.update()


def player_turn(board, player):
    """
    writes who's turn it is on top of the board
    :param board: game board so function knows where to write the text
    :param player: # of player who's turn it is
    """
    clear_player_turn(board)
    if len(board[0]) < 7:
        t.goto(len(board)*50, (len(board[0])*100)+55)
    else:
        t.goto(len(board) * 50, (len(board[0]) * 100) + 47)
    t.write("Player %d's Turn" % player, align='center', font=("OCR-A", 16, "normal"))
    t.goto(-100, -100)


def clear_player_turn(board):
    t.up()
    t.goto(((len(board)) * 40), ((len(board[0]) * 100) + 80))
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(200)
        t.right(90)
        if len(board[0]) < 7:
            t.forward(26)
        else:
            t.forward(33)
        t.right(90)
    t.end_fill()


def error_text(string, board):
    """
    The text printed below whoever's turn it is. It is mostly error statements and power up statements.
    :param string: The line being printed
    :param board: the game board, needed for knowing where to print text.
    """
    clear_error_text(board)
    t.up()
    t.goto(len(board) * 50, (len(board[0]) * 100) + 10)
    t.write(string, align='center', font=("OCR-A", 16, "normal"))
    t.goto(-100,-100)
    t.update()


def clear_error_text(board):
    """
    Clears the text written by error_text
    """
    t.up()
    t.goto(0, (len(board[0]) * 100) + 10)
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(len(board)*100)
        t.left(90)
        t.forward(36)
        t.left(90)
    t.end_fill()
    t.goto(-100, -100)
    t.update()


def rules():
    """
    Game rules, they will print if asked to be printed, then disappear once told.
    """
    rule=t.textinput("Game Rules", "Would you like to view the game rules?(Enter Yes to view or press enter to not)")
    if check_yes_no_print(rule):
        t.setworldcoordinates(0,5,100,100)
        t.goto(0,95)
        t.write("Game Rules:", font=("OCR-A", 16, "normal"))
        t.goto(0,92)
        t.write("Players will take turns choosing spots on the board where they will have the sum of all 4 tiles", font=("OCR-A", 16, "normal"))
        t.goto(0, 89)
        t.write("directly touching it added to their score and then that score gets placed on the board.", font=("OCR-A", 16, "normal"))
        t.goto(0,86)
        t.write("If you choose a spot where their are no tiles with values on any direct sides of it,", font=("OCR-A", 16, "normal"))
        t.goto(0, 83)
        t.write("then the tile's score will default to a value of 1.", font=("OCR-A", 16, "normal"))
        t.goto(0, 80)
        t.write("You cannot choose a spot on the boarder of the board,", font=("OCR-A", 16, "normal"))
        t.goto(0, 77)
        t.write("and you can also not choose a spot already chosen.", font=("OCR-A", 16, "normal"))
        t.goto(0, 74)
        t.write("The game will end when all tiles have been chosen.", font=("OCR-A", 16, "normal"))
        t.goto(0, 71)
        t.write("There can be between 2 and 4 players per game.", font=("OCR-A", 16, "normal"))
        t.goto(0, 68)
        t.write("You can choose the size of the board between 3 and 10 tiles for the rows and columns.", font=("OCR-A", 16, "normal"))
        t.goto(0, 65)
        t.write("Power Ups Modes:", font=("OCR-A", 16, "normal"))
        t.goto(0, 62)
        t.write("There are two different power ups modes, normal and mayhem with the only difference being", font=("OCR-A", 16, "normal"))
        t.goto(0, 59)
        t.write("that in normal mode approximately 15% of tiles are power ups, whereas in mayhem 100% are.", font=("OCR-A", 16, "normal"))
        t.goto(0, 56)
        t.write("Power ups:", font=("OCR-A", 16, "normal"))
        t.goto(0, 53)
        t.write("There are currently 11 different types of power ups.", font=("OCR-A", 16, "normal"))
        t.goto(0, 50)
        t.write("The simple ones are, score x 2, score negated, score - 10, and score + 10.", font=("OCR-A", 16, "normal"))
        t.goto(0, 47)
        t.write("More complicated ones include, 'X'ing out any tile on the board, this eliminates the ability to", font=("OCR-A", 16, "normal"))
        t.goto(0, 44)
        t.write("play on that tile, and subtracts whatever score was on the tile from the person's score.", font=("OCR-A", 16, "normal"))
        t.goto(0, 41)
        t.write("Random X's, which you get to choose the amount of X's randomly placed on the board.", font=("OCR-A", 16, "normal"))
        t.goto(0, 38)
        t.write("Next score negation where your score next turn will be negated.", font=("OCR-A", 16, "normal"))
        t.goto(0, 35)
        t.write("In the same vein, there's another power up which all opponents next scores are negated.", font=("OCR-A", 16, "normal"))
        t.goto(0, 32)
        t.write("Twice lost, the score that would have been added to your score instead is doubled and", font=("OCR-A", 16, "normal"))
        t.goto(0, 29)
        t.write("you get to choose whose score it is subtracted from.", font=("OCR-A", 16, "normal"))
        t.goto(0, 26)
        t.write("Swap, choose two tiles and swap them, the owners of each of the tiles remains the same,", font=("OCR-A", 16, "normal"))
        t.goto(0, 23)
        t.write("but te scores are swapped. If swapped with a playable tile, the new tile becomes playable", font=("OCR-A", 16, "normal"))
        t.goto(0, 20)
        t.write("and the other tile that was playable before gains the score that was on on the other tile.", font=("OCR-A", 16, "normal"))
        t.goto(0, 17)
        t.write("When done reading rules, Enter your number of players, and the game will begin.", font=("OCR-A", 16, "normal"))


def main():
    """
    This is the main method, it starts off by initializing the game, then it has a while loop that controls the
    operations of every turn.
    """
    rules()
    turn = 0
    neg = 0
    scores = [0, 0, -99999, -99999]
    negate=[0,0,0,0]
    p_spots = [[], [], [], []]
    (numP, scores) = player_num(scores)
    t.reset()
    (board) = initialize_board()
    draw_players(numP, board, scores)
    draw_board(len(board), len(board[0]))
    draw_1s(len(board), len(board[0]))
    if power_ups_on(board):
        boo = mayhem_on(board)
        board = power_init(board, boo)
        time.sleep(1)
        clear_error_text(board)
    while checker(board):
        if turn % numP == 0:
            t.pencolor('red')
            player_turn(board, turn % numP + 1)
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 1, p_spots, negate)
            t.pencolor('red')
        elif turn % numP == 1:
            t.pencolor('blue')
            player_turn(board, turn % numP + 1)
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 2, p_spots, negate)
            t.pencolor('blue')
        elif turn % numP == 2:
            t.pencolor('green')
            player_turn(board, turn % numP + 1)
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 3, p_spots, negate)
            t.pencolor('green')
        elif turn % numP == 3:
            t.pencolor('purple')
            player_turn(board, turn % numP + 1)
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 4, p_spots, negate)
            t.pencolor('purple')
        if neg > 0:
            neg -= 1
        scores[turn % numP] += board[row][col]
        draw_number(row, col, board[row][col])
        if power_up == "":
            pass
        elif power_up=='Choose X':
            Xout(board, scores, p_spots, (turn % numP)+1)
        elif power_up == 'Random X':
            RandX(board, scores, p_spots, (turn % numP)+1)
        elif power_up == 'Swap':
            (board, scores, p_spots) = swap(board, p_spots, scores, (turn % numP)+1)
        elif power_up == "Trap":
            trap(board, (turn % numP)+1)
        turn += 1
        draw_players(numP, board, scores)
        time.sleep(1.5)
        clear_error_text(board)
    end(scores, numP, board)
    t.done()


main()
exit()
