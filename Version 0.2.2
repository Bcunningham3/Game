"""
Game (Name TBD)
By: Brandon Cunningham
Version 0.2.2

Start Date: 10/15/2018
Finish Date: 10/17/2018

This version changed up graphics by allowing users to enter their own name, and using that name to represent them
instead of "Player #". Also fixed a human error where I confused rows and columns yup until this point, so all places
that said row actually meant column. As well as 3 more power ups were added.
"""


import turtle as t
import random as r
import time
t.tracer(0,0)
t.ht()


"""
All numbers must stick within a 20 by 40 rectangle.
the starting coordinates for 1 digit number is (40,30) from left hand corner.
The starting and ending position of each of these numbers will be the bottom left hand corner of their rectangles.
They will all start facing the right side wall and end the same direction.
All functions draw the number/symbol that is their function name.
"""
def num1():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.backward(10)
    t.left(90)
    t.forward(40)
    t.left(135)
    t.forward(14)
    t.up()
    t.goto(x,y)
    t.right(225)


def num2():
    x=t.xcor()
    y=t.ycor()
    t.down()
    t.forward(20)
    t.backward(20)
    t.left(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.up()
    t.left(180)
    t.goto(x,y)


def num3():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.backward(20)
    t.right(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.up()
    t.goto(x, y)
    t.left(180)


def num4():
    x = t.xcor()
    y = t.ycor()
    t.up()
    t.forward(17)
    t.left(90)
    t.down()
    t.forward(40)
    t.left(150)
    t.forward(34)
    t.left(120)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num5():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.left(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.right(90)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num6():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.left(90)
    t.forward(40)
    t.right(90)
    t.forward(20)
    t.up()
    t.goto(x, y)


def num7():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.goto(t.xcor()+20, t.ycor()+40)
    t.backward(20)
    t.up()
    t.goto(x, y)


def num8():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.left(90)
    t.forward(20)
    t.right(90)
    for z in range(4):
        t.forward(20)
        t.left(90)
    t.up()
    t.goto(x, y)


def num9():
    x = t.xcor()
    y = t.ycor()
    t.down()
    t.forward(20)
    t.left(90)
    t.forward(40)
    for z in range(3):
        t.left(90)
        t.forward(20)
    t.up()
    t.goto(x, y)


def num0():
    x = t.xcor()
    y = t.ycor()
    t.down()
    for z in range(2):
        t.forward(20)
        t.left(90)
        t.forward(40)
        t.left(90)
    t.up()
    t.goto(x, y)


def minus():
    x = t.xcor()
    y = t.ycor()
    t.goto(x, y+20)
    t.down()
    t.forward(20)
    t.up()
    t.goto(x, y)


def plus():
    x = t.xcor()
    y = t.ycor()
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.down()
    t.forward(20)
    t.backward(10)
    t.right(90)
    t.backward(10)
    t.forward(20)
    t.up()
    t.goto(x, y)


def star():
    t.pencolor("black")
    x = t.xcor()
    y = t.ycor()
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.down()
    t.forward(20)
    t.backward(10)
    t.right(90)
    t.backward(10)
    t.forward(20)
    t.backward(10)
    t.left(45)
    t.forward(10)
    t.backward(20)
    t.forward(10)
    t.left(90)
    t.forward(10)
    t.backward(20)
    t.forward(10)
    t.left(135)
    t.left(90)
    t.up()
    t.goto(x, y)


def draw_X():
    x = t.xcor()
    y = t.ycor()
    t.pencolor("black")
    t.forward(15)
    t.down()
    t.fillcolor("black")
    t.begin_fill()
    t.forward(5)
    t.goto(x+5, y+40)
    t.backward(5)
    t.goto(x+15, y)
    t.end_fill()
    t.up()
    t.backward(15)
    t.down()
    t.begin_fill()
    t.forward(5)
    t.goto(t.xcor()+15, t.ycor()+40)
    t.backward(5)
    t.goto(x,y)
    t.end_fill()
    t.up()


def calculate(board, numP, scores, neg, player, p_spots, negate, players, mayhem):
    """
    This is the function that will calculate your score based on the position you've chosen.
    :param board:
    :param numP:
    :param scores:
    :param neg:
    :param player:
    :param p_spots:
    :param negate:
    :return:
    """
    x=True
    n=0
    power_up=False
    TIMS=False
    while x:
        (row, col) = inputs(len(board), len(board[0]), players[player-1])
        spot = board[row][col]
        if spot == '$' or spot == '$-':
            if negate[player-1] > 0:
                TIMS=True
            (num)=adder(board, row, col)
            p_spots[player-1].append((row, col))
            if num == 0:
                num = 1
            if neg > 0:
                num *= -1
            if TIMS:
                num*=-1
                negate[player-1]-=1
            if spot == '$-':
                error_text("Trap Hit!", board)
                num=int(num*(-1.5))
            x = False
        elif spot == '*' or spot == '*-':
            A = str(board[row - 1][col])[0]
            B = str(board[row + 1][col])[0]
            C = str(board[row][col + 1])[0]
            D = str(board[row][col - 1])[0]
            if ((A == '$' or A == '*') and (B == '$' or B == '*') and (C == '$' or C == '*') and (D == '$' or D == '*')) and not mayhem:
                error_text("There must be a pre-chosen tile next to a power up in order to choose it.", board)
            else:
                num = adder(board, row, col)
                p_spots[player - 1].append((row, col))
                if negate[player - 1] > 0:
                    TIMS = True
                (num, scores, n, power_up, negate) = rand_power_up(num, numP, scores, board, player, negate)
                if neg > 0:
                    num *= -1
                if TIMS:
                    num *= -1
                    negate[player - 1] -= 1
                if spot == '*-':
                    error_text("Trap Hit!", board)
                    num = int(num * (-1.5))
                if power_up == "Twice Opp":
                    scores = twiceOpponent(num, scores, player, players)
                    num = 0
                t.up()
                t.goto(row*100, col*100)
                fill_spot("white")
                x = False
        elif spot == 'X':
            error_text("You cannot choose a spot that has already been eliminated.", board)
        else:
            error_text("You can't choose a position that has a value, please try again.", board)
    if n > 0 and neg > 0:
        neg += n - 1
    else:
        neg += n
    board[row][col] = num
    return board, row, col, scores, neg, p_spots, power_up


def adder(board, row, col):
    x = board[row - 1][col]
    if x == '*' or x == '$' or x == 'X' or x == '$-' or x == "*-":
        num = 0
    else:
        num = x
    x = board[row + 1][col]
    if x != '*' and x != '$' and x != 'X' and x != '$-' and x != "*-":
        num += x
    x = board[row][col + 1]
    if x != '*' and x != '$' and x != 'X' and x != '$-' and x != "*-":
        num += x
    x = board[row][col - 1]
    if x != '*' and x != '$' and x != 'X' and x != '$-' and x != "*-":
        num += x
    return num


def rand_power_up(num, numP, scores, board, player, negate):
    x = r.randint(1, 14)
    power_up = ""
    neg = 0
    if x==1:
        error_text("Scored Turned Negative", board)
        num *= -1
    elif x==2:
        error_text("10 subtracted from Score", board)
        num-=10
    elif x == 3:
        power_up="Twice Opp"
    elif x == 4:
        error_text("10 added to Score", board)
        num+=10
    elif x == 5:
        error_text("Score Multiplied by 2", board)
        num*=2
    elif x == 6:
        power_up = 'Choose X'
    elif x == 7:
        neg=negOpponents(numP, board)
    elif x == 8:
        power_up = 'Random X'
    elif x == 9:
        power_up = "Trap"
    elif x == 10:
        error_text("Your next turn will be negated", board)
        negate[player-1]+=1
    elif x == 11:
        power_up = 'Swap'
    elif x == 12:
        power_up = 'Gain Spot'
    elif x == 13:
        power_up = 'Lose Spot'
    elif x == 14:
        power_up = 'Betting'
        """
        Ideas: 
        All implemented
        """
    return num, scores, neg, power_up, negate


def trap(board, player):
    x = True
    error_text("Pick a spot to place a trap", board)
    while x:
        (row, col) = inputs(len(board), len(board[0]), player)
        if board[row][col] == '$':
            board[row][col] = '$-'
            x = False
        elif board[row][col] == '*':
            board[row][col] = '*-'
            x = False
        elif board[row][col] == 'X':
            error_text("You cannot choose a spot that has already been eliminated.", board)
        elif board[row][col] == '*-' or board[row][col] == '$-':
            x = False
        else:
            error_text("You can't choose a position that has already been chosen, please try again.", board)
    error_text("Trap Placed", board)


def Xout(board, scores, p_spots, player):
    error_text("Chose a spot that will be eliminated", board)
    boo =  True
    while boo:
        row=get_row(len(board)-2, player)
        col=get_col(len(board[0])-2, player)
        if board[row][col] != 'X':
            boo=False
            Xing(board, row, col, p_spots, scores)
        else:
            error_text("You cannot pick a spot that has already been eliminated", board)


def Xing(board, row, col, p_spots, scores):
    if (row, col) in p_spots[0]:
        scores[0]-=board[row][col]
    elif (row, col) in p_spots[1]:
        scores[1]-=board[row][col]
    elif (row, col) in p_spots[2]:
        scores[2]-=board[row][col]
    elif (row, col) in p_spots[3]:
        scores[3]-=board[row][col]
    board[row][col]='X'
    display_X(row, col)


def RandX(board, scores, p_spots, player):
    x=int((len(board[0])-2)*(len(board)-2)*.2)
    if x==1:
        x=2
    x=power_up_spots(board, x)
    num = get_num(player, x)
    while num > 0:
        row = r.randint(1, len(board) - 2)
        col = r.randint(1, len(board[0]) - 2)
        if board[row][col] != 'X':
            Xing(board, row, col, p_spots, scores)
            num -= 1


def get_num(player, x):
    try:
        return int(t.numinput("Player %d" % player, "Enter number of tiles to be randomly eliminated on board, between 1 and %d: " % x, 1, 1, x))
    except TypeError:
        exit()


def swap(board, p_spots, scores, player):
    error_text("Choose two spots on the board to swap Values. Enter first spot", board)
    row1 = get_row(len(board) - 2, player)
    col1 = get_col(len(board[0]) - 2, player)
    error_text("Choose second spot", board)
    row2 = get_row(len(board) - 2, player)
    col2 = get_col(len(board[0]) - 2, player)
    (val1, p1) = get_val(p_spots, board, scores, row1, col1)
    (val2, p2) = get_val(p_spots, board, scores, row2, col2)
    t.up()
    board[row1][col1] = val2
    board[row2][col2] = val1
    try:
        scores[p1] += val2
    except TypeError:
        pass
    try:
        scores[p2] += val1
    except TypeError:
        pass
    if p1 > -1 and p2 == -1:
        p_spots[p1].remove((row1, col1))
    if p2 > -1 and p1 == -1:
        p_spots[p2].remove((row2, col2))
    draw_swapped(val2, p1, row1, col1)
    draw_swapped(val1, p2, row2, col2)
    return board, scores, p_spots


def draw_swapped(val, p, row, col):
    t.goto(row * 100, col * 100)
    fill_spot("white")
    if val != '$':
        if p==-1:
            t.pencolor("black")
        elif p==0:
            t.pencolor("red")
        elif p==1:
            t.pencolor("blue")
        elif p==2:
            t.pencolor("green")
        elif p==3:
            t.pencolor("purple")
        draw_number(row, col, val)


def get_val(p_spots, board, scores, row1, col1):
    p=-1
    if (row1, col1) in p_spots[0]:
        p=0
        try:
            scores[0] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[1]:
        p=1
        try:
            scores[1] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[2]:
        p=2
        try:
            scores[2] -= board[row1][col1]
        except TypeError:
            pass
    elif (row1, col1) in p_spots[3]:
        p=3
        try:
            scores[3] -= board[row1][col1]
        except TypeError:
            pass
    return board[row1][col1], p


def power_up_spots(board, x):
    check=0
    for y in range(1, len(board)-1):
        for z in range(1, len(board[0])-1):
            if board[y][z]!='X':
                check+=1
                if x==check:
                    return check
    return check


def display_X(row, col):
    t.up()
    t.goto(row * 100, col * 100)
    fill_spot("white")
    one_digit('X')


def negOpponents(numP, board):
    error_text("All opponents next turns will be negative", board)
    return numP


def twiceOpponent(num, scores, player, players):
        player = get_player(player, (num*2), players)
        scores[player] -= (num*2)
        return scores


def betting(player, scores, numP, board, players):
    try:
        bet=int(t.numinput(players[player-1], "Enter the number of points you would like to bet, between 1 and 30: ", 30, 1, 30))
    except TypeError:
        exit()
    scores[player-1] -= bet
    draw_players(numP, board, scores, players)
    time.sleep(.5)
    bet=r.randint(0, 2*bet)
    error_text('You won %d points from your bet.' % bet, board)
    scores[player-1] += bet


def random_spot(board):
    row = r.randint(1, len(board) - 2)
    col = r.randint(1, len(board[0]) - 2)
    return row, col


def Gain_Spot(board, p_spots, player, scores):
    check = checker(board)
    while check:
        (row, col) = random_spot(board)
        if (row,col) in p_spots:
            print("yes")
        else:
            print("no")
        spot = board[row][col]
        try:
            if spot[0] == '$' or spot[0] == '*':
                error_text('Gain a random spot on board.', board)
                time.sleep(.75)
                p_spots[player].append((row, col))
                num = adder(board, row, col)
                scores[player] += num
                board[row][col] = num
                t.up()
                t.goto(row * 100, col * 100)
                fill_spot('white')
                t.pencolor(pen_color(player))
                draw_number(row, col, num)
                return p_spots, scores

        except:
            pass
    return p_spots, scores



def Lose_Spot(board, player, p_spots, scores):
    error_text("Lose a random spot you own.", board)
    time.sleep(.75)
    spot = r.randint(0, (len(p_spots[player])-1))
    row, col = p_spots[player][spot]
    scores[player] -= board[row][col]
    board[row][col] = '$'
    t.up()
    t.goto(row * 100, col * 100)
    fill_spot('white')
    return p_spots, scores


def inputs(w, h, player):
    """
    Temporary input method, will later change to graphics and mouse clicking.
    Or at least that is the plan, pygame was not working and I unfortunately
    may not be able to get it implemented in time.
    """
    row=get_row(w-2, player)
    col=get_col(h-2, player)
    return row, col


def get_player(player, num, players):
    while True:
        try:
            name = t.textinput(players[player-1], "Enter name of player number who will have " + str(num) + " subtracted from their score")
        except:
            exit()
        if name in players:
            return players.index(name)


def get_row(h, player):
    try:
        return int(t.numinput(player, "Enter column number, between 1 and %d: " % h, 1, 1, h))
    except TypeError:
        exit()


def get_col(w, player):
    try:
        return int(t.numinput(player, "Enter row number, between 1 and %d: " % w, 1, 1, w))
    except TypeError:
        exit()


def get_width():
    try:
        return int(t.numinput("Width", "Enter playable board width, between 3 and 10: ", 5, 3, 10))
    except TypeError:
        exit()

def get_height():
    try:
        return int(t.numinput("Height", "Enter playable board height, between 3 and 10: ", 5, 3, 10))
    except TypeError:
        exit()


def initialize_board():
    width = get_width()
    height = get_height()
    w, h = width+2, height+2
    board = [['$' for x in range(h)] for y in range(w)]
    for x in range(w):
        board[x][0] = 1
        board[x][h-1] = 1
    for x in range(h):
        board[0][x] = 1
        board[w-1][x] = 1
    t.setworldcoordinates(-25, -130, (w*100)+30, (h*100)+80)
    return board


def draw_board(w, h):
    t.up()
    t.pencolor("black")
    t.home()
    t.right(90)
    for x in range(0, w+1):
        t.goto(x*100, 0)
        t.down()
        t.backward(h*100)
        t.up()
    t.left(90)
    for x in range(0, h+1):
        t.goto(0, x * 100)
        t.down()
        t.forward(w * 100)
        t.up()
    t.home()
    fill_spot("black")
    t.goto(0, (h-1)*100)
    fill_spot("black")
    t.goto((w-1)*100, 0)
    fill_spot("black")
    t.goto((w-1)*100, (h-1)*100)
    fill_spot("black")
    t.home()


def draw_1s(w, h):
    for x in range(1, w-1):
        t.goto((x*100)+40, 30)
        num1()
        t.goto((x * 100) + 40, (h*100)-70)
        num1()
    for x in range(1, h-1):
        t.goto(40, (x*100)+30)
        num1()
        t.goto((w*100)-60, (x * 100) + 30)
        num1()
    t.goto(-100,-100)
    t.update()


def fill_spot(string):
    """
    Draws the black corners in the game, and clears spots that are being drawn over
    """
    t.down()
    t.pencolor('black')
    t.fillcolor(string)
    t.begin_fill()
    for x in range(4):
        t.forward(100)
        t.left(90)
    t.end_fill()
    t.up()


def draw_number(row, col, num):
    """
    Will print the score onto the drawn board
    """
    t.up()
    t.goto(row*100, col*100)
    try:
        if num > 999:
            num = "999+"
        if num < -999:
            num = "-999"
    except TypeError:
        pass
    num = str(num)
    if len(num) == 1:
        one_digit(num)
    elif len(num) == 2:
        two_digit(num)
    elif len(num) == 3:
        three_digit(num)
    else:
        more_digit(num)
    t.goto(-100,-100)
    t.update()


def one_digit(num):
    t.forward(40)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num)


def two_digit(num):
    t.forward(28)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])


def three_digit(num):
    t.forward(16)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])
    t.forward(24)
    draw_char(num[2])

def more_digit(num):
    t.forward(4)
    t.left(90)
    t.forward(30)
    t.right(90)
    draw_char(num[0])
    t.forward(24)
    draw_char(num[1])
    t.forward(24)
    draw_char(num[2])
    t.forward(24)
    draw_char(num[3])


def draw_char(char):
    if char == '*':
        star()
    elif char == '1':
        num1()
    elif char == '2':
        num2()
    elif char == '3':
        num3()
    elif char == '4':
        num4()
    elif char == '5':
        num5()
    elif char == '6':
        num6()
    elif char == '7':
        num7()
    elif char == '8':
        num8()
    elif char == '9':
        num9()
    elif char == '0':
        num0()
    elif char== '-':
        minus()
    elif char == '+':
        plus()
    elif char == 'X':
        draw_X()


def player_num(scores):
    try:
        numP = int(t.numinput("Players", "Enter number of players, between 2 and 4: ", 2, 2, 4))
    except TypeError:
        exit()
    players=[]
    for x in range(numP):
        (players, scores) = get_player_name(players, x+1, scores, [[0]])
    if numP>2:
        scores[2] = 0
    if numP>3:
        scores[3] = 0
    return numP, scores, players


def get_player_name(players, num, scores, board):
    check = True
    while check:
        try:
            name = t.textinput("Player %d" % num, "Enter Your name, between 1 and 20 characters")
            clear_error_text(board)
        except TypeError:
            exit()
        if len(name) > 0 and len(name) < 21:
            check = False
        else:
            error_text("Name must be between 1 and 20 characters", board)
        if name not in (x.upper() for x in players):
            players.append(name)
            scores[num - 1] = 0
        else:
            error_text("Name already taken", board)
            check = True
    return players, scores

def get_input():
    """
    Future ability to be able to click on the screen instead of having to type in
    the spots you choose to play in.
    This may turn out to be a very future thing because I cannot get pygame working.
    """
    pass
    #return row, col


def checker(board):
    """
    checks the board to see if there are any playable spots left
    :param board: the current state of the game board
    :return: wether or not the board is full and the game is over
    """
    for x in range(len(board)-1):
        for y in range(len(board[0])-1):
            if board[x+1][y+1]=='$' or board[x+1][y+1]=='*':
                return True
    return False


def end(scores, numP, board):
    clear_player_turn(board)
    if numP==2 and scores[0]==scores[1]:
        error_text("It's a Tie", board)
    if scores[0] > scores[1]:
        p1='Player 1'
        val1=scores[0]
    else:
        p1='Player 2'
        val1=scores[1]
    if scores[2] > scores[3]:
        p2='Player 3'
        val2=scores[2]
    else:
        p2='Player 4'
        val2=scores[3]
    if val1>val2:
        error_text(p1 + " Wins!!!", board)
    elif val2>val1:
        error_text(p2 + " Wins!!!", board)
    else:
        error_text("It's a Tie", board)


def power_ups_on(board):
    x=t.textinput("Game Mode", "Would you like to turn on power ups? (Enter Yes to turn them on or press enter to not)")
    return check_yes(x, board)


def mayhem_on(board):
    x = t. textinput("Game Mode", "Would you like to turn on mayhem mode? (Enter Yes to turn them on or press enter to not)")
    return check_yes(x, board)


def check_yes(x, board):
    try:
        x = x.upper()
    except:
        exit()
    if x != 'YES':
        return False
    error_text("Turned On", board)
    return True


def check_yes_no_print(x):
    try:
        x = x.upper()
    except:
        exit()
    if x != 'YES':
        return False
    return True


def power_init(board, boo):
    if not boo:
        spots = (len(board) - 2) * (len(board[0]) - 2)
        spots //= 7
        while spots > 0:
            row = r.randint(1, len(board) - 2)
            col = r.randint(1, len(board[0]) - 2)
            if board[row][col] != '*':
                board[row][col] = '*'
                display_power_ups(row, col)
                spots -= 1
    else:
        for row in range(1, len(board)-1):
            for col in range(1, len(board[0])-1):
                board[row][col] = '*'
                display_power_ups(row, col)
    return board


def display_power_ups(row, col):
    t.up()
    t.goto(row * 100, col * 100)
    one_digit('*')


def clear_players(board):
    t.goto(0,-1)
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(len(board)*100)
        t.right(90)
        t.forward(150)
        t.right(90)
    t.end_fill()


def draw_players(numP, board, scores, players):
    t.up()
    clear_players(board)
    t.goto(0, -50)
    t.down()
    t.pencolor("red")
    t.write(players[0] + ": %d" % scores[0], font=("OCR-A", 16, "normal"))
    t.up()
    t.goto((len(board)*100)/2, -50)
    t.down()
    t.pencolor("blue")
    t.write(players[1] + ": %d"% scores[1], font=("OCR-A", 16, "normal"))
    t.up()
    if numP>2:
        t.pencolor("green")
        t.goto(0, -100)
        t.down()
        t.write(players[2] + ": %d" % scores[2], font=("OCR-A", 16, "normal"))
        t.up()
    if numP>3:
        t.pencolor("purple")
        t.goto((len(board) * 100) / 2, -100)
        t.down()
        t.write(players[3] + ": %d" % scores[3], font=("OCR-A", 16, "normal"))
        t.up()
    t.goto(-100,-100)
    t.update()


def player_turn(board, player):
    """
    writes who's turn it is on top of the board
    :param board: game board so function knows where to write the text
    :param player: # of player who's turn it is
    """
    clear_player_turn(board)
    if len(board[0]) < 7:
        t.goto(len(board)*50, (len(board[0])*100)+55)
    else:
        t.goto(len(board) * 50, (len(board[0]) * 100) + 47)
    t.write(player+ "'s Turn", align='center', font=("OCR-A", 16, "normal"))
    t.goto(-100, -100)


def clear_player_turn(board):
    t.up()
    t.goto(((len(board)) * 40), ((len(board[0]) * 100) + 80))
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(200)
        t.right(90)
        if len(board[0]) < 7:
            t.forward(26)
        else:
            t.forward(33)
        t.right(90)
    t.end_fill()


def error_text(string, board):
    """
    The text printed below whoever's turn it is. It is mostly error statements and power up statements.
    :param string: The line being printed
    :param board: the game board, needed for knowing where to print text.
    """
    clear_error_text(board)
    t.up()
    t.goto(len(board) * 50, (len(board[0]) * 100) + 10)
    t.write(string, align='center', font=("OCR-A", 16, "normal"))
    t.goto(-100,-100)
    t.update()


def clear_error_text(board):
    """
    Clears the text written by error_text
    """
    t.up()
    t.goto(0, (len(board[0]) * 100) + 10)
    t.fillcolor("white")
    t.begin_fill()
    for x in range(2):
        t.forward(len(board)*100)
        t.left(90)
        t.forward(36)
        t.left(90)
    t.end_fill()
    t.goto(-100, -100)
    t.update()


def pen_color(player):
    if player == 0:
        return 'red'
    elif player == 1:
        return 'blue'
    elif player == 2:
        return 'green'
    elif player == 3:
        return 'purple'
    else:
        return 'black'


def rules():
    """
    Game rules, they will print if asked to be printed, then disappear once told.
    """
    rule=t.textinput("Game Rules", "Would you like to view the game rules?(Enter Yes to view or press enter to not)")
    t.setworldcoordinates(0, 15, 100, 115)
    if check_yes_no_print(rule):
        x = 110
        y = 3
        t.goto(0,x)
        t.write("Game Rules:", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0,x)
        t.write("Players will take turns choosing spots on the board where they will have the sum of all 4 tiles", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("directly touching it added to their score and then that score gets placed on the board.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("If you choose a spot where their are no tiles with values on any direct sides of it,", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("then the tile's score will default to a value of 1.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("You cannot choose a spot on the boarder of the board,", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("and you can also not choose a spot already chosen.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("The game will end when all tiles have been chosen.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("There can be between 2 and 4 players per game.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("You can choose the size of the board between 3 and 10 tiles for the rows and columns.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("You will be prompted for a row/column, the spot (1, 1) is always the bottom left corner, ", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("and the spot (max width, max height) is always the top right corner, ", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Power Ups Modes:", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("There are two different power ups modes, normal and mayhem with the only difference being", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("that in normal mode approximately 15% of tiles are power ups, whereas in mayhem 100% are.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Power ups:", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("There are currently 14 different types of power ups.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("The simple ones are, score x 2, score negated, score - 10, and score + 10.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("More complicated ones include, eliminating any tile on the board, this stops the tile from being", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("playable, and subtracts whatever score was on the tile from the person's score.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Random X's, which you get to choose the amount of X's randomly placed on the board.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Next score negation where your score next turn will be negated.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("In the same vein, there's another power up which all opponents next scores are negated.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Twice lost, the score that would have been added to your score instead is doubled and", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("you get to choose whose score it is subtracted from.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Swap, choose two tiles and swap them, the owners of each of the tiles remains the same,", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("but the scores are swapped. If swapped with a playable tile, the new tile becomes playable", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("and the other tile that was playable before gains the score that was on on the other tile.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Gain/lose tile, these will cause you to either gain a random, unoccupied tile, or lose a tile", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("you already own respectively.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("Betting, you enter in the amount you want to bet, up to 30, and you will get back", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("A random amount between 0 and twice what you bet.", font=("OCR-A", 16, "normal"))
        x -= y
        t.goto(0, x)
        t.write("When done reading rules, enter your number of players, and the game will begin.", font=("OCR-A", 16, "normal"))


def main():
    """
    This is the main method, it starts off by initializing the game, then it has a while loop that controls the
    operations of every turn.
    """
    rules()
    mayhem = False
    turn = 0
    neg = 0
    scores = [0, 0, -99999, -99999]
    negate=[0,0,0,0]
    p_spots = [[], [], [], []]
    (numP, scores, players) = player_num(scores)
    t.reset()
    (board) = initialize_board()
    draw_players(numP, board, scores, players)
    draw_board(len(board), len(board[0]))
    draw_1s(len(board), len(board[0]))
    if power_ups_on(board):
        mayhem = mayhem_on(board)
        board = power_init(board, mayhem)
        time.sleep(1)
        clear_error_text(board)
    while checker(board):
        current_player = turn % numP
        if current_player == 0:
            t.pencolor('red')
            player_turn(board, players[current_player])
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 1, p_spots, negate, players, mayhem)
            t.pencolor('red')
        elif current_player == 1:
            t.pencolor('blue')
            player_turn(board, players[current_player])
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 2, p_spots, negate, players, mayhem)
            t.pencolor('blue')
        elif current_player == 2:
            t.pencolor('green')
            player_turn(board, players[current_player])
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 3, p_spots, negate, players, mayhem)
            t.pencolor('green')
        elif current_player == 3:
            t.pencolor('purple')
            player_turn(board, players[current_player])
            (board, row, col, scores, neg, p_spots, power_up) = calculate(board, numP, scores, neg, 4, p_spots, negate, players, mayhem)
            t.pencolor('purple')
        if neg > 0:
            neg -= 1
        scores[current_player] += board[row][col]
        draw_number(row, col, board[row][col])
        if power_up == "":
            pass
        elif power_up=='Choose X':
            Xout(board, scores, p_spots, players[current_player])
        elif power_up == 'Random X':
            RandX(board, scores, p_spots, players[current_player])
        elif power_up == 'Swap':
            (board, scores, p_spots) = swap(board, p_spots, scores, players[current_player])
        elif power_up == "Trap":
            trap(board, players[current_player])
        elif power_up == 'Gain Spot':
            (p_spots, scores) = Gain_Spot(board, p_spots, current_player, scores)
        elif power_up == 'Lose Spot':
            Lose_Spot(board, current_player, p_spots, scores)
        draw_players(numP, board, scores, players)
        if power_up == 'Betting':
            betting(current_player + 1, scores, numP, board, players)
        turn += 1
        time.sleep(1.5)
        clear_error_text(board)
    end(scores, numP, board)
    t.done()


main()
exit()
